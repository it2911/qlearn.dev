---
title: "量子计算的 if 和 while"
menuTitle: "量子计算的 if 和 while"
date: 2019-11-20T09:25:33+09:00
weight: 3090
pre: "<b>9.</b>"
tags: ["量子程序基础知识"]
---

&emsp;&emsp;所谓量子线路，从本质上是一个量子逻辑门的执行序列，它是从左至右依次执行的。即使介绍了函数调用的思想，也可以理解为这是一种简单地内联展开，即把函数中的所有逻辑门插入到调用处，自然地，可能会考虑在量子计算机的层面是否存在类似于经典计算机中的循环和分支语句。因此，就有了 **QIF** 和 **QWHILE**。

#### 9.1 基于测量的跳转

&emsp;&emsp;作为 QIF 和 QWHILE 的判断条件的对象，并不是量子比特，而是一个经典的信息，往往，这个经典的信息是基于测量的。
在量子程序执行时，测量语句会对量子比特施加一个测量操作，之后将这个比特的测量结果保存到经典寄存器中，最后，可以根据这个经典寄存器的值，选择接下来要进行的操作。例如：

```
H -> q
Meas q -> c
Qif (c == Zero) H->q
```

&emsp;&emsp;这样的量子程序表示的是对 q 进行 Hadamard 门操作之后，测量它；如果测量的结果是 0，则再做一个 Hadamard 门。
从这个例子可以继续延伸到 Qif 可以包裹的一系列语句，而不仅仅是一个，比如:

```
Qif (c == Zero) {
    H->q
    CNOT(q0, q1)
    ……
}
```

&emsp;&emsp;或者也可以设置 Qelse 语句，它表示如果判断条件为非，则要执行的语句。例如：

```
Qif (c == Zero) { 
    CNOT(q0, q1)
}Qelse {
    CNOT(q1,q0)
}
```

&emsp;&emsp;再或许可以综合两个、多个量子比特的测量结果，对它们进行布尔代数运算，进行判断。
另一种情况是将 N 个量子比特的测量结果理解为一个 **N-bit 整数**，之后再与其他整数进行比较。

&emsp;&emsp;例如：

```
Qif (c1 == Zero && c2 == One) {
    H->q
    CNOT(q0, q1)
    ……
}
```

&emsp;&emsp;上述规则对于 QWhile 来说也是一样，比如一个随机计数的代码：
```
c = One
n = Zero
QWhile(c) {
    H -> q
    Meas q->c
    n ++
}
```

&emsp;&emsp;这个程序的含义是每次对 **qubit** 执行 **Hadamard** 门并测量，如果测量结果为 1 则继续该过程，测量结果为 0 则退出循环。
这表明测量得到 1 的次数，每次都有 1/2 的概率，给定计数器 n+1，最终可以取得 n 的值。重复这个实验，可以拟合出一个负指数分布。
另外，**QIf** 和 **QWhile** 是可以相互嵌套的，形成多层的控制流。

#### 9.2 基于量子信息的 IF 和 WHILE

&emsp;&emsp;上述的是“量子信息，经典控制”，那么有没有“量子信息，量子控制”呢？对于 IF而言，答案是有的。

&emsp;&emsp;定义“**量子信息，量子控制**”过程是一组量子比特的操作，是由另一组比特的值决定的。
一个最简单的例子就是 CNOT 门，对于 CNOT(q0,q1)而言，q1 是否执行 NOT 门是由 q0 的值决定的。基于量子信息的 IF 的性质如下：

&emsp;&emsp;**第一**，这种控制可以叠加。如果判断变量本身处于叠加态，那么操作的比特也会出现执行/不执行逻辑门的两种分支，由此，判断变量和操作比特之间会形成纠缠态。例如：

```
H -> q1
CNOT q1 -> q2
```

&emsp;&emsp;此时得到的量子态是|00>+|11>，这样在 CNOT 后，就把 q1 这个判断变量和 q2 这个操作比特纠缠了起来。

&emsp;&emsp;**第二**，控制变量和操作比特之间不能共享比特。即， CNOT(q0,q1)中控制位和目标位一定不能为相同的量子比特。

&emsp;&emsp;基于量子信息的 IF 在实际的量子算法中使用得比较少，因此大部分量子软件开发包都没有加入这个功能。
在 Shor 算法和其他基于布尔运算的线路中会使用这个思想，比如对是否求模的判断，但实际中，一般是利用 CNOT 门的组合来实现的。

&emsp;&emsp;对于 WHILE 而言，目前还没有找到一个合适的定义，因为量子信息不确定，那么很有可能会在 WHILE 中产生无法停机的分支。
以经典控制的 QWhile 作为例子，如果控制变量 c 是一个量子比特，那么每次都会有一个概率使得这个循环继续下去。
因此，为了执行这个序列，就需要无限长的操作序列，这导致从物理上无法定义这种操作。